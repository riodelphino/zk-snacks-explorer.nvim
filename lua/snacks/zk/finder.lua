-- ---@param opts snacks.picker.explorer.Config
-- ---@type snacks.picker.finder
-- function M.zk_finder(opts, ctx)
--    local notes_cache = require("snacks.zk").notes_cache
--    local explorer = require("snacks.picker.source.explorer")
--
--    -- 元の finder を取得（explorer または search）
--    local base_finder = explorer.explorer(opts, ctx)
--
--    return function(cb)
--       base_finder(function(item)
--          -- item.sort を書き換える
--          if item.file then
--             local basename = vim.fs.basename(item.file)
--
--             -- Markdown ファイルの場合、title を使う
--             if item.file:match("%.md$") then
--                local note = notes_cache[item.file]
--                if note and note.title and note.title ~= "" then
--                   basename = note.title
--                end
--             end
--
--             -- 親のソートキーを取得
--             local parent_sort = ""
--             if item.parent and item.parent.sort then
--                parent_sort = item.parent.sort
--             elseif item.sort then
--                -- 既存の sort から親部分を抽出
--                parent_sort = item.sort:match("^(.*)([!#])") or ""
--             end
--
--             -- 新しいソートキーを生成
--             if item.dir then
--                item.sort = parent_sort .. "!" .. basename:lower() .. " "
--             else
--                item.sort = parent_sort .. "#" .. basename:lower() .. " "
--             end
--          end
--
--          cb(item)
--       end)
--    end
-- end

-- ---@param opts snacks.picker.explorer.Config
-- ---@type snacks.picker.finder
-- function M.zk_finder(opts, ctx)
--    local notes_cache = require("snacks.zk").notes_cache
--    local state = require("snacks.picker.source.explorer").get_state(ctx.picker)
--
--    if state:setup(ctx) then
--       return M.search(opts, ctx)
--    end
--
--    if opts.git_status then
--       require("snacks.explorer.git").update(ctx.filter.cwd, {
--          untracked = opts.git_untracked,
--          on_update = function()
--             if ctx.picker.closed then
--                return
--             end
--             ctx.picker.list:set_target()
--             ctx.picker:find()
--          end,
--       })
--    end
--
--    if opts.diagnostics then
--       require("snacks.explorer.diagnostics").update(ctx.filter.cwd)
--    end
--
--    return function(cb)
--       if state.on_find then
--          ctx.picker.matcher.task:on("done", vim.schedule_wrap(state.on_find))
--          state.on_find = nil
--       end
--       local items = {} ---@type table<string, snacks.picker.explorer.Item>
--       local top = Tree:find(ctx.filter.cwd)
--       local last = {} ---@type table<snacks.picker.explorer.Node, snacks.picker.explorer.Item>
--       Tree:get(ctx.filter.cwd, function(node)
--          local parent = node.parent and items[node.parent.path] or nil
--          local status = node.status
--          if not status and parent and parent.dir_status then
--             status = parent.dir_status
--          end
--          local item = {
--             file = node.path,
--             dir = node.dir,
--             open = node.open,
--             dir_status = node.dir_status or parent and parent.dir_status,
--             text = node.path,
--             parent = parent,
--             hidden = node.hidden,
--             ignored = node.ignored,
--             status = (not node.dir or not node.open or opts.git_status_open) and status or nil,
--             last = true,
--             type = node.type,
--             severity = (not node.dir or not node.open or opts.diagnostics_open) and node.severity or nil,
--          }
--          if last[node.parent] then
--             last[node.parent].last = false
--          end
--          last[node.parent] = item
--          if top == node then
--             item.hidden = false
--             item.ignored = false
--          end
--          item.title = notes_cache[node.path] and notes_cache[node.path].title
--          item.sort = item.title or ""
--          items[node.path] = item
--          cb(item)
--       end, { hidden = opts.hidden, ignored = opts.ignored, exclude = opts.exclude, include = opts.include })
--    end
-- end

-- -- item.sort でソートする設定？
-- ---@param opts snacks.picker.explorer.Config
-- ---@type snacks.picker.finder
-- function M.zk_finder(opts, ctx)
--    local notes_cache = require("snacks.zk").notes_cache
--    local explorer = require("snacks.picker.source.explorer")
--    local base_finder = explorer.explorer(opts, ctx)
--
--    return function(cb)
--       base_finder(function(item)
--          -- item.sort を書き換える
--          if item.type == "directory" then
--             item.sort = item.file
--          elseif item.type == "file" then
--             if item.file and item.file:match("%.md$") then
--                local note = notes_cache[item.file]
--                if note and note.title and note.title ~= "" then
--                   -- sort の最後の部分（basename）を title に置き換え
--                   -- 例: "!parent#basename " → "!parent#title "
--                   -- local prefix = item.sort:match("^(.+[!#])")
--                   -- if prefix then
--                   --    item.sort = prefix .. note.title:lower() .. " "
--                   -- end
--                   item.sort = vim.fs.joinpath(vim.fn.fnamemodify(item.file, ":p:h"), note.title)
--                else
--                   item.sort = item.file
--                end
--             else
--                item.sort = item.file
--             end
--          end
--          print(vim.inspect(item))
--
--          cb(item)
--       end)
--    end
-- end

---@param opts snacks.picker.explorer.Config
---@type snacks.picker.finder
local finder = function(opts, ctx)
   local notes_cache = require("snacks.zk").notes_cache
   local explorer = require("snacks.picker.source.explorer")
   local base_finder = explorer.explorer(opts, ctx)

   return function(cb)
      base_finder(function(item)
         if item.type == "file" then
            if item.file and item.file:match("%.md$") then
               local note = notes_cache[item.file]
               if note and note.title and note.title ~= "" then
                  -- vim.fs.joinpath(vim.fn.fnamemodify(item.file, ":p:h"), note.title)
                  item.title = note.title
               end
            end
         end
         if not item.title then -- titleでソートするには全アイテムが title を保持しないといけないかも、の対策
            item.title = item.file
         end
         cb(item)
      end)
   end
end

-- ---@param opts snacks.picker.explorer.Config
-- ---@type snacks.picker.finder
-- function M.zk_finder(opts, ctx)
--    -- local notes_cache = require("snacks.zk").notes_cache
--    -- local explorer = require("snacks.picker.source.explorer")
--    -- local base_finder = explorer.explorer(opts, ctx)
--    --
--    -- return function(cb)
--    --    local wrapped_cb = function(item)
--    --       -- 親のソートキー
--    --       local parent_sort = item.parent and item.parent.sort or ""
--    --
--    --       -- basename を取得（title があれば title を使う）
--    --       local basename = vim.fs.basename(item.file)
--    --       if item.file:match("%.md$") then
--    --          local note = notes_cache[item.file]
--    --          print(vim.inspect(note))
--    --          if note and note.title and note.title ~= "" then
--    --             basename = note.title
--    --          end
--    --       end
--    --
--    --       -- 階層的ソートキーを生成
--    --       if item.dir then
--    --          item.sort = parent_sort .. "!" .. basename:lower() .. " "
--    --       else
--    --          item.sort = parent_sort .. "#" .. basename:lower() .. " "
--    --       end
--    --
--    --       cb(item)
--    --    end
--    --
--    --    base_finder(wrapped_cb)
--    -- end
--
--    local state = M.get_state(ctx.picker)
--
--    if state:setup(ctx) then
--       return M.search(opts, ctx)
--    end
--
--    if opts.git_status then
--       require("snacks.explorer.git").update(ctx.filter.cwd, {
--          untracked = opts.git_untracked,
--          on_update = function()
--             if ctx.picker.closed then
--                return
--             end
--             ctx.picker.list:set_target()
--             ctx.picker:find()
--          end,
--       })
--    end
--
--    if opts.diagnostics then
--       require("snacks.explorer.diagnostics").update(ctx.filter.cwd)
--    end
--
--    return function(cb)
--       if state.on_find then
--          ctx.picker.matcher.task:on("done", vim.schedule_wrap(state.on_find))
--          state.on_find = nil
--       end
--       local items = {} ---@type table<string, snacks.picker.explorer.Item>
--       local top = Tree:find(ctx.filter.cwd)
--       local last = {} ---@type table<snacks.picker.explorer.Node, snacks.picker.explorer.Item>
--       Tree:get(ctx.filter.cwd, function(node)
--          local parent = node.parent and items[node.parent.path] or nil
--          local status = node.status
--          if not status and parent and parent.dir_status then
--             status = parent.dir_status
--          end
--          local item = {
--             file = node.path,
--             dir = node.dir,
--             open = node.open,
--             dir_status = node.dir_status or parent and parent.dir_status,
--             text = node.path,
--             parent = parent,
--             hidden = node.hidden,
--             ignored = node.ignored,
--             status = (not node.dir or not node.open or opts.git_status_open) and status or nil,
--             last = true,
--             type = node.type,
--             severity = (not node.dir or not node.open or opts.diagnostics_open) and node.severity or nil,
--          }
--          if last[node.parent] then
--             last[node.parent].last = false
--          end
--          last[node.parent] = item
--          if top == node then
--             item.hidden = false
--             item.ignored = false
--          end
--          items[node.path] = item
--          cb(item)
--       end, { hidden = opts.hidden, ignored = opts.ignored, exclude = opts.exclude, include = opts.include })
--    end
-- end

-- local explorer = require("snacks.picker.source.explorer")
--
-- ---@param opts snacks.picker.explorer.Config
-- ---@type snacks.picker.finder
-- Snacks.picker.sources.explorer["zk_finder"] = function(opts, ctx)
--    print("find")
--    local notes_cache = require("snacks.zk").notes_cache
--    local state = explorer.get_state(ctx.picker)
--
--    if state:setup(ctx) then
--       return explorer.search(opts, ctx)
--    end
--
--    if opts.git_status then
--       require("snacks.explorer.git").update(ctx.filter.cwd, {
--          untracked = opts.git_untracked,
--          on_update = function()
--             if ctx.picker.closed then
--                return
--             end
--             ctx.picker.list:set_target()
--             ctx.picker:find()
--          end,
--       })
--    end
--
--    if opts.diagnostics then
--       require("snacks.explorer.diagnostics").update(ctx.filter.cwd)
--    end
--
--    return function(cb)
--       if state.on_find then
--          ctx.picker.matcher.task:on("done", vim.schedule_wrap(state.on_find))
--          state.on_find = nil
--       end
--       local items = {} ---@type table<string, snacks.picker.explorer.Item>
--       local top = Tree:find(ctx.filter.cwd)
--       local last = {} ---@type table<snacks.picker.explorer.Node, snacks.picker.explorer.Item>
--       Tree:get(ctx.filter.cwd, function(node)
--          local parent = node.parent and items[node.parent.path] or nil
--          local status = node.status
--          if not status and parent and parent.dir_status then
--             status = parent.dir_status
--          end
--          local item = {
--             file = node.path,
--             dir = node.dir,
--             open = node.open,
--             dir_status = node.dir_status or parent and parent.dir_status,
--             text = node.path,
--             parent = parent,
--             hidden = node.hidden,
--             ignored = node.ignored,
--             status = (not node.dir or not node.open or opts.git_status_open) and status or nil,
--             last = true,
--             type = node.type,
--             severity = (not node.dir or not node.open or opts.diagnostics_open) and node.severity or nil,
--          }
--          if last[node.parent] then
--             last[node.parent].last = false
--          end
--          last[node.parent] = item
--          if top == node then
--             item.hidden = false
--             item.ignored = false
--          end
--          items[node.path] = item
--          cb(item)
--       end, { hidden = opts.hidden, ignored = opts.ignored, exclude = opts.exclude, include = opts.include })
--    end
-- return function(cb)
--  return function(cb)
--    base_finder(function(item)
--       -- Markdown ファイルの場合、title をソートキーに設定
--       if item.file and item.file:match("%.md$") then
--          local note = notes_cache[item.file]
--          if note and note.title then
--             -- title の小文字版をソートキーに
--             item.sort = note.title:lower()
--          else
--             -- title がない場合はファイル名
--             item.sort = vim.fs.basename(item.file):lower()
--          end
--       elseif item.dir then
--          -- ディレクトリは先頭に来るように
--          item.sort = "!" .. vim.fs.basename(item.file):lower()
--       else
--          -- その他のファイル
--          item.sort = vim.fs.basename(item.file):lower()
--       end
--
--       cb(item)
--    end)
-- end
--
-- end

return finder
